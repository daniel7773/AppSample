package ru.mts.money.articles.navigator

import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentStatePagerAdapter
import androidx.viewpager.widget.PagerAdapter
import ru.mts.money.framework.base.BaseFragment

class NavigatorAdapter(val fragmentManager: FragmentManager) : FragmentStatePagerAdapter(fragmentManager) {
    //Используем ArrayList для создания динамического стэка фрагментов
    private val listOfFragments: ArrayList<BaseFragment> = ArrayList()

    //Добавляем фрагмент
    fun addFragment(fragment: BaseFragment) {
        listOfFragments.add(fragment)
        notifyDataSetChanged()
    }

    // Удаляем фрагмент
    fun removeLastFragment() {
        listOfFragments.removeAt(listOfFragments.size - 1)
        notifyDataSetChanged()
    }

    // Получаем размер стэка фрагментов
    fun getFragmentsCount(): Int {
        return listOfFragments.size
    }

    override fun getItemPosition(`object`: Any): Int {
        val index = listOfFragments.indexOf(`object`)
        // Используем для предотвращения дублирования фрагментов в стеке
        return if (index == -1)
            PagerAdapter.POSITION_NONE
        else
            index
    }

    override fun getItem(position: Int): Fragment {
        return listOfFragments[position]
    }

    override fun getCount(): Int {
        return listOfFragments.size
    }

    override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
        super.destroyItem(container, position, `object`)
    }
}
package ru.mts.money.articles.navigator

import android.view.View
import androidx.viewpager.widget.ViewPager

class NavigatorPageTransformer : ViewPager.PageTransformer {

    override fun transformPage(view: View, position: Float) {

        // PageTransformer используется для анимации между переходами экранов
        view.apply {
            val pageWidth = width
            when {
                // Все экраны в стеке справа от текущего
                position <= -1 -> {
                    // Используем флаг INVISIBLE у всех экранов справа от текущего
                    // для оптимизации рендеринга
                    visibility = View.INVISIBLE
                }

                // Экран, который появляется справа от текущего при открытии нового фрагмента
                position > 0 && position <= 1 -> {
                    visibility = View.VISIBLE
                    translationX = 0f
                }

                // Анимация ухода текущего фрагмента влево при открытии нового
                // (со смещением и изменением прозрачности, помните черный бэкграунд у NavigatorViewPager?)
                position <= 0 -> {
                    translationX = -pageWidth * position / 1.3F
                    visibility = View.VISIBLE
                }

                //Все врагменты слева от текущего, убираем их из отрисовки
                else -> {
                    visibility = View.INVISIBLE
                }
            }
        }
    }
}
package ru.mts.money.articles.navigator

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.view.animation.DecelerateInterpolator
import android.widget.Scroller
import androidx.viewpager.widget.ViewPager

class NavigatorViewPager : ViewPager {

    init {
        init()
    }

    constructor(context: Context) : super(context)
    constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet)

    override fun canScrollHorizontally(direction: Int): Boolean {
        return false
    }

    // инициализируем
    private fun init() {
        // PageTransformer нужен для переопределения анимаций открываемых фрагментов
        setPageTransformer(false, NavigatorPageTransformer())

        // Отключаем оверскролл
        overScrollMode = View.OVER_SCROLL_NEVER

        //Поскольку стандартная анимация открытия новой страницы слишком быстрая, 
        // используем свое поведение
        setDurationScroll(300)
    }

    // Устанавливаем продолжительность анимации открытия фрагмента
    fun setDurationScroll(millis: Int) {
        try {
            val viewpager = ViewPager::class.java
            val scroller = viewpager.getDeclaredField("mScroller")
            scroller.isAccessible = true
            scroller.set(this, OwnScroller(context, millis))
        } catch (e: Exception) {
            e.printStackTrace()
        }

    }

    //Добавляем интерполятор для замедления открытия фрагмента DecelerateInterpolator()
    inner class OwnScroller(context: Context, durationScroll: Int) : Scroller(context, DecelerateInterpolator(1.5f)) {
        private var durationScrollMillis = 1
        init {
            this.durationScrollMillis = durationScroll
        }

        override fun startScroll(startX: Int, startY: Int, dx: Int, dy: Int, duration: Int) {
            super.startScroll(startX, startY, dx, dy, durationScrollMillis)
        }
    }
}
